<h2>Мапы</h2>

<h3>Теория:</h3>

Вопросы

<ul>
    <li>
        Как происходит вставка и поиск по ключу?
    </li>
    <li>
        Как получается константная сложность этих операций?
    </li>
    <li>
        Какой порядок перебора мапы?
    </li>
    <li>
        Почему нельзя взять ссылку на значение в мапе (эвакуация данных)?
    </li>
</ul>

<section>
    <h3>Устройство мапы</h4>
    <p>
        В момент создания мапы m := make(map[int]int) создаются бакеты (допустим 4). Бакет - структура, которая содержит в себе набор структур данных (массивов): tophash, key, value.
    </p>
    <p>
        При добавление нового значения в мапу m[1] = 10 создается хэш (уникальное значение), которое соответствует ключу 1. Дальше необходимо положить хэш и значение в бакет.
    </p>
    <p>
        Получить последние биты с хэша (low order bits). Кол-во битов рассчитывается по формуле log с основанием 2 от кол-ва бакетов (в какую степень нужно возвести 2, чтобы получилось кол-во бакетов).
    </p>
    <p>
        В tophash кладется 1 байт хэша, дальше ключ и значение. Дальше заполняется бакет другими ключами и значениями.
    </p>
</section>

<section>
    <h3>Вычисление константной сложности</h4>
    <p>
        Рассчет хэша - O(1); получение двух последних битов хэша - O(1); взять первый байт хэша - O(1); добавили первый байт в массив tophash - O(1); добавили ключ и значение в массивы - O(1) и O(1). Итого - O(1).
    </p>
    <p>
        Сложность не всегда O(1), так как могут быть коллизии, когда хэщ-функция сегнерирует значения с одинаковым хвостом. Это приведет к тому, что значения будет добавляться в один бакет, а другие останутся пустыми. Сложность будет O(N).
    </p>
</section>

<section>
    <h3>Поиск по ключу</h4>
    <p>
        Сначала получаем хэш по значению. Берет два последних бита для определения бакета. Берем первый байт и ищем по нему в tophash
    </p>
    <p>
        Сложность. Расчет хэша - O(1); получение двух последних битов с хэша - O(1); взять первый байт хэша - O(1); сравнить первый байт с каэждым элементом массива tophash - O(8) = 0(1); сравнить ключ с каждым элементом массива ключей - O(8) = O(1); получить значение по тому же значению, что и найденный ключ - O(1). Итого - O(1).
    </p>
</section>

<section>
    <h3>Итерация по мапе</h4>
    <p>
        Порядок ключей при итерации рандомный
    </p>
</section>

<section>
    <h3>Эвакуация данных</h4>
    <p>
        При полном заполнение бакетов (k=6.5) создаются новые бакеты для миграции данных. В процессе эвакуации итерация идет по старым бакетам. Как только бакет будет мигрирован, то поиск будет по новому бакету. Отсюда значит, что после эвакуации данных мы не сможем взять ссылку на значение в мапе и получим ошибку.
    </p>
    <p>
        Конкуретная запись в мапу невозможна, так как одна запись может создавать эвакуацию, а другая писать в старый бакет.
    </p>
    <p>
        Каждая эвакуация - это дополнительная аллокация памяти и дополнительные накладные расходы.
    </p>
    <p>
        Из мапы можно только конкуретно читать, но не писать.
    </p>
</section>

<h3>Задачи:</h3>

<details>
    <summary>
       Лекция 3.5. Вариант №1
    </summary>
    <pre><code>
        type User struct {}
        m := make(map[User]int)
        u := User{}
        m[u] = 2
        fmt.Println(&m[u]) // Ошибка компиляции. Эвакуация данных.
        fmt.Println(m{&u}) // Ошибка компиляции. Неправильный тип: ключ мапы не является ссылкой (мы задали User).
    </pre></code>
</details>

<details>
    <summary>
       Лекция 3.5. Вариант №2
    </summary>
    <pre><code>
        m := make(map[int]int)
        wg := &sync.WaitGroup{}
        wg.Add(100)
        //
        for i:= range 100 {
            go func() {
                defer wg.Done()
                m[i] = i
            }()
        }
        //
        wg.Wait()
    </pre></code>
    <details>
        <summary>
            Решение
        </summary>
        <pre><code>
            m := make(map[int]int)
            wg := &sync.WaitGroup{}
            mu := &sync.Mutex{}
            wg.Add(100)
            //
            for i:= range 100 {
                go func() {
                    defer wg.Done()
                    mu.Lock()
                    defer mu.Unlock()
                    m[i] = i
                }()
            }
            //
            wg.Wait()
        </pre></code>
    </details>
</details>